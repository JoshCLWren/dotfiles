# Loading zshrc.local...
# Powerlevel10k instant prompt - must be at the top
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Oh My Zsh configuration
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="" # We use Powerlevel10k instead
plugins=(git)

# Source Oh My Zsh
[[ -f "$ZSH/oh-my-zsh.sh" ]] && source "$ZSH/oh-my-zsh.sh"

# Set PATH at the very beginning
path=(
    # System paths
    "/usr/local/bin"
    "/usr/bin"
    "/bin"
    "/usr/sbin"
    "/sbin"
    "/opt/homebrew/bin"
    # Additional paths
    "/opt/homebrew/opt/curl/bin"
    "/opt/homebrew/opt/unzip/bin"
    "/opt/homebrew/opt/openjdk/bin"
    "/opt/homebrew/opt/icu4c@77/bin"
    "/opt/homebrew/opt/icu4c@77/sbin"
    "$HOME/.codeium/windsurf/bin"
    "$HOME/.local/bin"
    "$HOME/dotfiles-local/zsh-git-prompt/src/.bin"
    "$HOME/.cargo/bin"
    "$HOME/bin"
    "$HOME/code/youversion/openapi/redcli"
    "$HOME/code/youversion/bi-tools"
    "$GOPATH/bin"
    "$HOME/code/youversion/yv/bin"
    "$HOME/.nvm/versions/node/v23.8.0/bin"
    $path[@]
)
# Then add other paths

# Initialize pyenv if available
if command -v pyenv 1>/dev/null 2>&1; then
    # Ensure no existing pyenv function conflicts
    unset -f pyenv 2>/dev/null || true
    eval "$(pyenv init -)"
    eval "$(pyenv virtualenv-init -)"
fi

# Python auto-activation functions
find_python_version_file() {
  local current_dir=$(pwd)

  while [[ "$current_dir" != "/" ]]; do
    if [[ -f "$current_dir/.python-version" ]]; then
      echo "$current_dir/.python-version"
      return 0
    fi
    current_dir=$(dirname "$current_dir")
  done

  return 1
}

auto_pyenv_activate_or_deactivate() {
  local python_version_file=$(find_python_version_file)

  if [[ -n "$python_version_file" ]]; then
    local version
    version=$(cat "$python_version_file")
    # Check if the version is installed
    if pyenv versions --bare | grep -qx "$version"; then
      echo "Activating Python $version from $python_version_file"
      pyenv activate "$version" 2>/dev/null || pyenv local "$version"
    else
      echo "Python version $version not installed. Consider installing it with 'pyenv install $version'"
    fi
  else
    echo "No .python-version found, deactivating any active pyenv environment"
    pyenv deactivate  # Reverts to the system Python
  fi
}

# Hook the function to directory changes
autoload -U add-zsh-hook
add-zsh-hook chpwd auto_pyenv_activate_or_deactivate

# Initial check in case you start in a directory with .python-version
auto_pyenv_activate_or_deactivate
# Lazy load NVM
export NVM_DIR="$HOME/.nvm"
nvm() {
  unfunction nvm
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
  nvm "$@"
}
node() {
  unfunction node
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  node "$@"
}
npm() {
  unfunction npm
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  npm "$@"
}
# Set up Go environment (cached)
if [[ -z "$GOROOT" ]] && command -v brew >/dev/null 2>&1; then
  export GOROOT="$(brew --prefix golang 2>/dev/null)/libexec"
fi
export GOPATH="$HOME/go"
# Source powerlevel10k
source /opt/homebrew/share/powerlevel10k/powerlevel10k.zsh-theme
source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh
# Editor setting
export EDITOR="code -w"

# History configuration
HISTSIZE=5000
SAVEHIST=5000
setopt HIST_IGNORE_SPACE
setopt HIST_IGNORE_DUPS
setopt HIST_EXPIRE_DUPS_FIRST

alias undo='git restore --staged . && git restore . && git clean -fd'
alias be='bundle exec'
alias status='git status'
alias commit='git commit'
alias add='git add .'
alias rspec='bundle exec rspec'
alias refresh='source ~/.zshrc'
alias bug='pytest -sxv tests --last-failed --pdb'
alias mouse='tmux set mouse'
alias sniff="sniffer -x tests"
alias gagrc='git add .; git rebase --continue'
alias new='git checkout -b'
alias z='vim  ~/dotfiles/zshrc.local'
alias nyan='cd ~/go-nyancat && ./go-nyancat | lolcat'
alias gl="git log --oneline --decorate --graph -10"
alias gti='git'
alias bu="brew update"
alias _rebase='git pull origin main --rebase'
alias k='kubectl'

# Keep your existing functions
# [Rest of your functions remain the same]

# Lazy load jump and fnm
if command -v jump >/dev/null 2>&1; then
  jump() {
    unfunction jump j 2>/dev/null
    eval "$(command jump shell)"
    jump "$@"
  }
  # Create j alias that also lazy loads
  j() {
    unfunction jump j 2>/dev/null
    eval "$(command jump shell)"
    j "$@"
  }
fi

if command -v fnm >/dev/null 2>&1; then
  fnm() {
    unfunction fnm
    eval "$(command fnm env --use-on-cd)"
    fnm "$@"
  }
fi

# Hook direnv into the shell
if command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi

# Source Google Cloud SDK
if [ -f "$HOME/google-cloud-sdk/path.zsh.inc" ]; then
    source "$HOME/google-cloud-sdk/path.zsh.inc"
fi

if [ -f "$HOME/google-cloud-sdk/completion.zsh.inc" ]; then
    source "$HOME/google-cloud-sdk/completion.zsh.inc"
fi

export USE_GKE_GCLOUD_AUTH_PLUGIN=True
export LEFTHOOK=0

# Source cargo environment if it exists
[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# Source git utilities from separate file
[[ -f "$HOME/dotfiles/git-large-file-fix" ]] && source "$HOME/dotfiles/git-large-file-fix"

export DOCKER_HOST="unix://${HOME}/.colima/default/docker.sock"


function fix_colima_docker() {
  echo "üîç Checking DOCKER_HOST..."
  if [[ -n "$DOCKER_HOST" ]]; then
    echo "‚ö†Ô∏è  DOCKER_HOST is set to: $DOCKER_HOST"
    echo "üßπ Unsetting DOCKER_HOST"
    unset DOCKER_HOST
  fi

  echo "üê≥ Testing Docker connection..."
  if docker ps > /dev/null 2>&1; then
    echo "‚úÖ Docker is working fine."
    return 0
  fi

  echo "‚ùå Docker connection failed. Attempting to fix..."

  echo "üõë Stopping Colima..."
  colima stop

  echo "üóëÔ∏è Deleting Colima (this will wipe container data)..."
  echo "y" | colima delete

  echo "üöÄ Restarting Colima..."
  colima start --arch aarch64 --mount "$HOME" --dns 1.1.1.1

  echo "üîÅ Switching Docker context to 'colima'..."
  docker context use colima

  echo "‚è≥ Waiting for Docker to respond..."
  for i in {1..10}; do
    if docker ps > /dev/null 2>&1; then
      echo "‚úÖ Docker is working again!"
      return 0
    fi
    sleep 2
  done

  echo "‚ùå Docker still not responding after restart."
  return 1
}

# Utility functions from _zshrc.local
function killport() {
    if [ $# -eq 0 ]; then
        echo "usage: killport [port]\nnote: separate multiple ports with comma"
    else
        kill $(lsof -ti:$1)
    fi
}

function findport() {
    if [ $# -eq 0 ]; then
        echo "usage: findport [port]"
    else
        netstat -vanp tcp | grep $1
    fi
}

function redspec() {
    if [ $# -eq 0 ]; then
        echo "usage: redspec [service-name]"
    else
        redcli $1 .
    fi
}

function git-cleanup() {
    git branch --merged | egrep -v "(^\*|master|develop|main)" | xargs -n 1 git branch -d
}

function git-delete-all-branches() {
    git branch | egrep -v "(^\*|master|develop|main)" | xargs -n 1 git branch -D
}

# Kubernetes functions
kube-get-pod() {
    kubectl get pods --no-headers |
        fzf \
            --bind="ctrl-r:reload(kubectl get pods --no-headers)" \
            --header="$P9K_KUBECONTEXT_NAME/$P9K_KUBECONTEXT_NAMESPACE (Press CTRL-R to reload)" \
            --height=25% |
        grep -o -E '^[^ ]+'
}

kube-pod-widget() {
    local pod=$(kube-get-pod | join-lines)
    zle reset-prompt
    LBUFFER+=$pod
}

join-lines() {
  local item
  while read item; do
    echo -n "${(q)item} "
  done
}

zle -N kube-pod-widget
bindkey '^k' kube-pod-widget

# Kubernetes aliases
alias kxa='kubectl exec $(kube-get-pod) -c api-app -it -- bash'
alias kx='kubectl exec $(kube-get-pod) -it -- bash'
alias red='redspec organizations'

# Build args function
yvba() {
    local target_machine="gitlab.com"
    local login=$(awk -v machine="$target_machine" '
    $1 == "machine" && $2 == machine {found=1}
    found && $1 == "login" {print $2; found=0}    ' ~/.netrc)
    local password=$(awk -v machine="$target_machine" '
    $1 == "machine" && $2 == machine {found=1}        found && $1 == "password" {print $2; found=0}    ' ~/.netrc)
    local build_args=(        "--build-arg GITLAB_REPO_USERNAME=${login}"
    "--build-arg GITLAB_REPO_TOKEN=${password}"
    "--build-arg GITLAB_USER=${login}"
    "--build-arg GITLAB_PASSWORD=${password}"
    "--build-arg PYPI_USERNAME=${login}"
    "--build-arg PYPI_PASSWORD=${password}"
    "--build-arg YV_DOCKER_CACHE=${YV_DOCKER_CACHE}"
    "--build-arg YV_REGISTRY=${YV_REGISTRY}"    )
    for arg in "$@"; do
    build_args+=("--build-arg $arg")
    done
    echo "${build_args[@]}"
}
# Source work-specific configuration
[[ -f "$HOME/dotfiles/work.zsh" ]] && source "$HOME/dotfiles/work.zsh"
