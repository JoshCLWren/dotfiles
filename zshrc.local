setopt interactivecomments

# Loading zshrc.local...
# Powerlevel10k instant prompt - must be at the top
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Detect operating system
case "${DOTFILES_OS_OVERRIDE:-$(uname -s)}" in
  Darwin) DOTFILES_OS="macos" ;;
  Linux) DOTFILES_OS="linux" ;;
  *) DOTFILES_OS="other" ;;
esac
export DOTFILES_OS

# Oh My Zsh configuration
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="" # We use Powerlevel10k instead
plugins=(git)

# Source Oh My Zsh
[[ -f "$ZSH/oh-my-zsh.sh" ]] && source "$ZSH/oh-my-zsh.sh"

# Set PATH at the very beginning
typeset -a _mac_paths _dotfiles_path
if [[ "$DOTFILES_OS" == "macos" ]]; then
  _mac_paths=(
    "/opt/homebrew/bin"
    "/opt/homebrew/opt/curl/bin"
    "/opt/homebrew/opt/unzip/bin"
    "/opt/homebrew/opt/openjdk/bin"
    "/opt/homebrew/opt/icu4c@77/bin"
    "/opt/homebrew/opt/icu4c@77/sbin"
  )
fi

_dotfiles_path=(
  # System paths
  "/usr/local/bin"
  "/usr/bin"
  "/bin"
  "/usr/sbin"
  "/sbin"
)
if [[ "$DOTFILES_OS" == "macos" ]]; then
  _dotfiles_path+=("${_mac_paths[@]}")
fi
_dotfiles_path+=(
  # Additional paths
  "$HOME/.codeium/windsurf/bin"
  "$HOME/.local/bin"
  "$HOME/dotfiles-local/zsh-git-prompt/src/.bin"
  "$HOME/.cargo/bin"
  "$HOME/bin"
  "$HOME/code/youversion/openapi/redcli"
  "$HOME/code/youversion/bi-tools"
  "$GOPATH/bin"
  "$HOME/code/youversion/yv/bin"
)
path=(
  "${_dotfiles_path[@]}"
  $path[@]
)
unset _mac_paths _dotfiles_path

# Initialize pyenv if available
# Disabled - using uv venvs instead
# if command -v pyenv 1>/dev/null 2>&1; then
#     # Ensure no existing pyenv function conflicts
#     unset -f pyenv 2>/dev/null || true
#     eval "$(pyenv init -)"
#     eval "$(pyenv virtualenv-init -)"
# fi

# Initialize rbenv if available
if command -v rbenv 1>/dev/null 2>&1; then
    eval "$(rbenv init - zsh)"
fi

# NVM configuration with smart PATH setup
export NVM_DIR="$HOME/.nvm"

# Add default NVM node bin to PATH immediately (for npm global binaries like 'claude')
# This avoids slow NVM loading while ensuring npm globals are in PATH
if [[ -f "$NVM_DIR/alias/default" ]]; then
  _nvm_default_version=$(cat "$NVM_DIR/alias/default")
  # Handle aliases like 'lts/*' or version numbers
  if [[ -d "$NVM_DIR/versions/node/v${_nvm_default_version}" ]]; then
    path=("$NVM_DIR/versions/node/v${_nvm_default_version}/bin" $path)
  elif [[ -d "$NVM_DIR/versions/node/${_nvm_default_version}" ]]; then
    path=("$NVM_DIR/versions/node/${_nvm_default_version}/bin" $path)
  else
    # Find the actual version for aliases like 'lts/*'
    for dir in "$NVM_DIR"/versions/node/v*; do
      if [[ -d "$dir" ]]; then
        path=("$dir/bin" $path)
        break
      fi
    done
  fi
  unset _nvm_default_version
fi

# Lazy load NVM (full initialization deferred until first use)
nvm() {
  unfunction nvm
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
  nvm "$@"
}
node() {
  unfunction node
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  node "$@"
}
npm() {
  unfunction npm
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  npm "$@"
}
# Set up Go environment (cached)
if [[ -z "$GOROOT" ]]; then
  if command -v go >/dev/null 2>&1; then
    go_root="$(go env GOROOT 2>/dev/null)"
    [[ -n "$go_root" ]] && export GOROOT="$go_root"
  elif [[ "$DOTFILES_OS" == "macos" ]] && command -v brew >/dev/null 2>&1; then
    # Homebrew installs expose GOROOT via libexec; Linux installs often self-manage via go env
    export GOROOT="$(brew --prefix golang 2>/dev/null)/libexec"
  fi
fi
unset go_root
export GOPATH="$HOME/go"
# Utility: source the first readable file from a candidate list
source_first_existing() {
  local candidate
  for candidate in "$@"; do
    if [[ -r "$candidate" ]]; then
      source "$candidate"
      return 0
    fi
  done
  return 1
}

# Source powerlevel10k theme if available
case "$DOTFILES_OS" in
  macos)
    source_first_existing \
      "/opt/homebrew/share/powerlevel10k/powerlevel10k.zsh-theme" \
      "$ZSH/custom/themes/powerlevel10k/powerlevel10k.zsh-theme" \
      "$HOME/.oh-my-zsh/custom/themes/powerlevel10k/powerlevel10k.zsh-theme" \
      "$HOME/powerlevel10k/powerlevel10k.zsh-theme"
    ;;
  linux)
    source_first_existing \
      "$ZSH/custom/themes/powerlevel10k/powerlevel10k.zsh-theme" \
      "$HOME/.oh-my-zsh/custom/themes/powerlevel10k/powerlevel10k.zsh-theme" \
      "$HOME/powerlevel10k/powerlevel10k.zsh-theme" \
      "/usr/share/powerlevel10k/powerlevel10k.zsh-theme" \
      "/usr/local/share/powerlevel10k/powerlevel10k.zsh-theme"
    ;;
  *)
    source_first_existing \
      "$ZSH/custom/themes/powerlevel10k/powerlevel10k.zsh-theme" \
      "$HOME/.oh-my-zsh/custom/themes/powerlevel10k/powerlevel10k.zsh-theme" \
      "$HOME/powerlevel10k/powerlevel10k.zsh-theme"
    ;;
esac

if [[ -r "$HOME/dotfiles/p10k.zsh" ]]; then
  source "$HOME/dotfiles/p10k.zsh"
elif [[ -r "$HOME/.p10k.zsh" ]]; then
  source "$HOME/.p10k.zsh"
fi

# Source zsh-autosuggestions plugin if available
case "$DOTFILES_OS" in
  macos)
    source_first_existing \
      "/opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh" \
      "$ZSH/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh" \
      "/usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh" \
      "/usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
    ;;
  linux)
    source_first_existing \
      "$ZSH/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh" \
      "/usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh" \
      "/usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
    ;;
  *)
    source_first_existing \
      "$ZSH/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh"
    ;;
esac

unset -f source_first_existing
# Editor setting
export VISUAL=vim
export EDITOR=vim

# History configuration
HISTSIZE=5000
SAVEHIST=5000
setopt HIST_IGNORE_SPACE
setopt HIST_IGNORE_DUPS
setopt HIST_EXPIRE_DUPS_FIRST

alias undo='git restore --staged . && git restore . && git clean -fd'
alias be='bundle exec'
alias status='git status'
alias commit='git commit'
alias add='git add .'
alias rspec='bundle exec rspec'
alias refresh='source ~/.zshrc'
alias ..='cd ..'
alias bug='pytest -sxv tests --last-failed --pdb'
alias mouse='tmux set mouse'
alias sniff="sniffer -x tests"
alias gagrc='git add .; git rebase --continue'
alias new='git checkout -b'
alias nyan='cd ~/go-nyancat && ./go-nyancat | lolcat'
alias gl="git log --oneline --decorate --graph -10"
alias gti='git'
alias bu="brew update"
alias _rebase='git pull origin main --rebase'
alias k='kubectl'
alias gemini-cli='gemini'

# GKE cluster credentials (use --internal-ip for access via Netskope/VPN)
alias gke-staging='USE_GKE_GCLOUD_AUTH_PLUGIN=True gcloud container clusters get-credentials yv-api-staging --internal-ip --region us-central1 --project yv-api-staging'
alias gke-prod='USE_GKE_GCLOUD_AUTH_PLUGIN=True gcloud container clusters get-credentials yv-api-prod --internal-ip --region us-central1 --project yv-api-production'
alias gcloud-auth='~/dotfiles/gcloud_auto_auth.py'

# User-defined aliases and functions
alias pycharm='open -a "/Users/joshwren/Applications/PyCharm.app"'
alias kx='kubectl exec $(kube-get-pod) -it -- bash'
alias kxa='kubectl exec $(kube-get-pod) -c api-app -it -- bash'

function killport() {
    if [ $# -eq 0 ]; then
        echo "usage: killport [port]\nnote: separate multiple ports with comma"
    else
        kill $(lsof -ti:$1)
    fi
}

function findport() {
    if [ $# -eq 0 ]; then
        echo "usage: findport [port]"
    else
        netstat -vanp tcp | grep $1
    fi
}

function redspec() {
    if [ $# -eq 0 ]; then
        echo "usage: redspec [service-name]"
    else
        redcli $1 .
    fi
}

function git-cleanup() {
    git branch --merged | egrep -v "(^\*|master|develop|main)" | xargs -n 1 git branch -d
}

function git-delete-all-branches() {
    git branch | egrep -v "(^\*|master|develop|main)" | xargs -n 1 git branch -D
}

kube-get-pod() {
    kubectl get pods --no-headers |
        fzf \
            --bind="ctrl-r:reload(kubectl get pods --no-headers)" \
            --header="$P9K_KUBECONTEXT_NAME/$P9K_KUBECONTEXT_NAMESPACE (Press CTRL-R to reload)" \
            --height=25% |
        grep -o -E '^[^ ]+'
}

kube-pod-widget() {
    local pod=$(kube-get-pod | join-lines)
    zle reset-prompt
    LBUFFER+=$pod
}

join-lines() {
  local item
  while read item; do
    echo -n "${(q)item} "
  done
}

# Kubernetes widget key binding
zle -N kube-pod-widget
bindkey '^k' kube-pod-widget

# Function to recursively find .python-version from the current directory up to the root
find_python_version_file() {
  local current_dir=$(pwd)

  while [[ "$current_dir" != "/" ]]; do
    if [[ -f "$current_dir/.python-version" ]]; then
      echo "$current_dir/.python-version"
      return 0
    fi
    current_dir=$(dirname "$current_dir")
  done

  return 1
}

# Function to check for .python-version and activate or deactivate pyenv
# Prefers uv venvs in ~/.venvs/ if they exist
auto_pyenv_activate_or_deactivate() {
  local name="${PWD##*/}"
  local uv_venv=~/.venvs/"$name"

  # Prefer uv venv if it exists
  if [[ -d "$uv_venv" ]]; then
    source "$uv_venv"/bin/activate 2>/dev/null
    return
  fi

  local python_version_file=$(find_python_version_file)

  if [[ -n "$python_version_file" ]]; then
    local version
    version=$(cat "$python_version_file")
    # Check if the version is installed
    if pyenv versions --bare | grep -qx "$version"; then
      pyenv activate "$version" 2>/dev/null || pyenv local "$version"
    fi
  else
    pyenv deactivate 2>/dev/null  # Reverts to the system Python
  fi
}

# Hook for automatic pyenv activation
autoload -U add-zsh-hook
add-zsh-hook chpwd auto_pyenv_activate_or_deactivate
add-zsh-hook -D precmd _pyenv_virtualenv_hook
export PYENV_VIRTUALENV_DISABLE_PROMPT=1

# Initial check in case you start in a directory with .python-version
auto_pyenv_activate_or_deactivate

yvba() {
    local target_machine="gitlab.com"
    local login=$(awk -v machine="$target_machine" '
    $1 == "machine" && $2 == machine {found=1}
    found && $1 == "login" {print $2; found=0}    ' ~/.netrc)
    local password=$(awk -v machine="$target_machine" '
    $1 == "machine" && $2 == machine {found=1}        found && $1 == "password" {print $2; found=0}    ' ~/.netrc)
    local build_args=(        "--build-arg GITLAB_REPO_USERNAME=${login}"
    "--build-arg GITLAB_REPO_TOKEN=${password}"
    "--build-arg GITLAB_USER=${login}"
    "--build-arg GITLAB_PASSWORD=${password}"
    "--build-arg PYPI_USERNAME=${login}"
    "--build-arg PYPI_PASSWORD=${password}"
    "--build-arg YV_DOCKER_CACHE=${YV_DOCKER_CACHE}"
    "--build-arg YV_REGISTRY=${YV_REGISTRY}"    )
    for arg in "$@"; do
    build_args+=("--build-arg $arg")
    done
    echo "${build_args[@]}"
}

# Load evalcache for performance
[[ -f "$HOME/dotfiles/evalcache.zsh" ]] && source "$HOME/dotfiles/evalcache.zsh"

# Platform-specific directory jumping
if [[ "$DOTFILES_OS" == "macos" ]] && command -v jump >/dev/null 2>&1; then
  # Use jump on macOS with lazy loading
  if command -v _evalcache >/dev/null 2>&1; then
    _evalcache jump shell
  else
    jump() {
      unfunction jump j 2>/dev/null
      eval "$(command jump shell)"
      jump "$@"
    }
    j() {
      unfunction jump j 2>/dev/null
      eval "$(command jump shell)"
      j "$@"
    }
  fi
elif [[ "$DOTFILES_OS" == "linux" ]] && command -v zoxide >/dev/null 2>&1; then
  # Use zoxide on Linux
  eval "$(zoxide init zsh)"
  alias j='z'  # Alias j to zoxide's z for consistency with macOS
fi

if command -v fnm >/dev/null 2>&1; then
  if command -v _evalcache >/dev/null 2>&1; then
    _evalcache fnm env --use-on-cd
  else
    fnm() {
      unfunction fnm
      eval "$(command fnm env --use-on-cd)"
      fnm "$@"
    }
  fi
fi

# Source Google Cloud SDK
if [ -f "$HOME/google-cloud-sdk/path.zsh.inc" ]; then
    source "$HOME/google-cloud-sdk/path.zsh.inc"
fi

if [ -f "$HOME/google-cloud-sdk/completion.zsh.inc" ]; then
    source "$HOME/google-cloud-sdk/completion.zsh.inc"
fi

export USE_GKE_GCLOUD_AUTH_PLUGIN=True
export LEFTHOOK=0

# Source cargo environment if it exists
[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# Source git utilities from separate file
[[ -f "$HOME/dotfiles/git-large-file-fix" ]] && source "$HOME/dotfiles/git-large-file-fix"

# Load fzf key bindings and completion
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Hook direnv into the shell after pyenv is loaded
if command -v _evalcache >/dev/null 2>&1; then
  _evalcache direnv hook zsh
elif command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi

# Initialize yv if available
if [ -f "/Users/joshwren/Code/youversion/yv/bin/yv" ]; then
  if command -v _evalcache >/dev/null 2>&1; then
    _evalcache /Users/joshwren/Code/youversion/yv/bin/yv init -
  else
    eval "$(/Users/joshwren/Code/youversion/yv/bin/yv init -)"
  fi
fi

# Background update check for brew and npm
function check_package_updates() {
  local cache_file="$HOME/.cache/package_updates_check"
  local cache_duration=$((24 * 60 * 60)) # 24 hours in seconds

  # Create cache directory if it doesn't exist
  mkdir -p "$(dirname "$cache_file")"

  # Check if cache file exists and is recent
  if [[ -f "$cache_file" ]]; then
    local last_check=0
    if command -v stat >/dev/null 2>&1; then
      # macOS/BSD: stat -f %m ; Linux/GNU: stat -c %Y
      last_check=$(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null || echo 0)
      # Ensure numeric (strip whitespace/newlines); avoid math errors if stat prints unexpected text
      last_check=${last_check//$'\n'/}
      last_check=${last_check//[[:space:]]/}
      [[ "$last_check" == <-> ]] || last_check=0
    fi
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_check))

    if [[ $time_diff -lt $cache_duration ]]; then
      return 0
    fi
  fi

  # Run checks in background
  {
    local updates=""

    # Check brew updates
    if command -v brew >/dev/null 2>&1; then
      local brew_outdated=$(brew outdated 2>/dev/null | wc -l | tr -d ' ')
      if [[ $brew_outdated -gt 0 ]]; then
        updates="${updates}üì¶ Homebrew: $brew_outdated package(s) can be updated (run 'brew upgrade')\n"
      fi
    fi

    # Check npm global updates
    if command -v npm >/dev/null 2>&1; then
      local npm_outdated=$(npm outdated -g 2>/dev/null | tail -n +2 | wc -l | tr -d ' ')
      if [[ $npm_outdated -gt 0 ]]; then
        updates="${updates}üì¶ npm: $npm_outdated global package(s) can be updated (run 'npm update -g')\n"
      fi
    fi

    # Update cache file
    touch "$cache_file"

    # Show updates if any
    if [[ -n "$updates" ]]; then
      echo "\n${updates}" >> "$cache_file.log"
      # Only show notification if there are updates
      echo -e "$updates"
    fi
  } &!
}

# Run check on shell startup
check_package_updates

if [[ "$DOTFILES_OS" == "macos" ]] && command -v colima >/dev/null 2>&1; then
  export DOCKER_HOST="unix://${HOME}/.colima/default/docker.sock"

function fix_colima_docker() {
  echo "üîç Checking DOCKER_HOST..."
  if [[ -n "$DOCKER_HOST" ]]; then
    echo "‚ö†Ô∏è  DOCKER_HOST is set to: $DOCKER_HOST"
    echo "üßπ Unsetting DOCKER_HOST"
    unset DOCKER_HOST
  fi

  echo "üê≥ Testing Docker connection..."
  if docker ps > /dev/null 2>&1; then
    echo "‚úÖ Docker is working fine."
    return 0
  fi

  echo "‚ùå Docker connection failed. Attempting to fix..."

  echo "üõë Stopping Colima..."
  colima stop

  echo "üóëÔ∏è Deleting Colima (this will wipe container data)..."
  echo "y" | colima delete

  echo "üöÄ Restarting Colima..."
  colima start --arch aarch64 --mount "$HOME" --dns 1.1.1.1

  echo "üîÅ Switching Docker context to 'colima'..."
  docker context use colima

  echo "‚è≥ Waiting for Docker to respond..."
  for i in {1..10}; do
    if docker ps > /dev/null 2>&1; then
      echo "‚úÖ Docker is working again!"
      return 0
    fi
    sleep 2
  done

  echo "‚ùå Docker still not responding after restart."
  return 1
}
fi
# Source work-specific configuration (keep platform-specific logic bundled there)
[[ -f "$HOME/dotfiles/work.zsh" ]] && source "$HOME/dotfiles/work.zsh"

# ============================================================================
# UV (replaces pyenv + pip + pip-tools)
# Hijacks make targets locally for speed
# ============================================================================

make() {
  case "$1" in
    venv) shift; uvenv "$@" ;;
    deps-install) uvinstall ;;
    deps-update) uvupdate ;;
    deps-compile) shift; uvcompile "$@" ;;
    *) command make "$@" ;;
  esac
}

# Detect if this is a uv project (has pyproject.toml with project metadata)
_is_uv_project() {
  [[ -f pyproject.toml ]] && grep -q '^\[project\]' pyproject.toml
}

# Get the venv path for the current project
_get_venv_path() {
  if _is_uv_project; then
    echo "$PWD/.venv"
  else
    echo "$HOME/.venvs/${PWD##*/}"
  fi
}

uvenv() {
  local py="${1:-3.11}"
  local name="${PWD##*/}"

  if _is_uv_project; then
    # Use local .venv for uv projects
    uv venv .venv --python "$py"
    source .venv/bin/activate
  else
    # Use ~/.venvs/ for traditional projects
    mkdir -p ~/.venvs
    uv venv ~/.venvs/"$name" --python "$py"
    source ~/.venvs/"$name"/bin/activate
  fi
}

uvinstall() {
  local venv=$(_get_venv_path)

  # Create venv if it doesn't exist
  if [[ ! -d "$venv" ]]; then
    echo "Creating venv at $venv..."
    if _is_uv_project; then
      uv venv .venv
    else
      mkdir -p ~/.venvs
      uv venv "$venv"
    fi
  fi

  # For uv projects, use uv sync (handles pyproject.toml)
  if _is_uv_project; then
    # Temporarily unset VIRTUAL_ENV to avoid mismatch warnings
    local old_venv="$VIRTUAL_ENV"
    unset VIRTUAL_ENV

    # Initialize if not already done
    if [[ ! -f uv.lock ]]; then
      echo "Initializing uv project..."
      uv init --no-readme 2>/dev/null || true
    fi

    # Sync dependencies
    uv sync

    # Restore and activate the correct venv
    export VIRTUAL_ENV="$venv"
    source "$venv/bin/activate"
  else
    # Legacy requirements.txt workflow
    [[ -f requirements.txt ]] && uv pip install --python "$venv" -r requirements.txt
    [[ -f requirements-dev.txt ]] && uv pip install --python "$venv" -r requirements-dev.txt
    [[ -f requirements-mikey.txt ]] && uv pip install --python "$venv" -r requirements-mikey.txt
    [[ -f requirements-mikey-dev.txt ]] && uv pip install --python "$venv" -r requirements-mikey-dev.txt

    # Activate the venv
    source "$venv/bin/activate"
  fi

  echo "‚úÖ Venv activated: $venv"
}

uvcompile() {
  local pkg="$1"
  if [[ -n "$pkg" ]]; then
    [[ -f requirements.in ]] && uv pip compile requirements.in -o requirements.txt -P "$pkg"
    [[ -f requirements-dev.in ]] && uv pip compile requirements-dev.in -o requirements-dev.txt -P "$pkg"
  else
    [[ -f requirements.in ]] && uv pip compile requirements.in -o requirements.txt
    [[ -f requirements-dev.in ]] && uv pip compile requirements-dev.in -o requirements-dev.txt
  fi
}

uvupdate() {
  local venv=$(_get_venv_path)

  if _is_uv_project; then
    # For uv projects, use uv lock --upgrade
    uv lock --upgrade
    uv sync
  else
    # Legacy workflow
    [[ -f requirements.in ]] && uv pip compile requirements.in -o requirements.txt --upgrade
    [[ -f requirements-dev.in ]] && uv pip compile requirements-dev.in -o requirements-dev.txt --upgrade
    uv pip sync --python "$venv" requirements*.txt
  fi
}

uvsetup() {
  uvenv "${1:-3.11}"
  uvinstall
}

uvnuke() {
  local venv=$(_get_venv_path)
  echo "üóëÔ∏è  Removing venv at $venv..."
  rm -rf "$venv"
  echo "üî® Recreating venv..."
  uvinstall
}

# Deduplicate PATH entries while preserving order (must be at the very end)
# This removes duplicates added by tools like pyenv, google-cloud-sdk, rbenv, etc.
typeset -U path
export PATH