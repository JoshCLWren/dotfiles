# Loading zshrc.local...
# Powerlevel10k instant prompt - must be at the top
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Oh My Zsh configuration
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="" # We use Powerlevel10k instead
plugins=(git)

# Source Oh My Zsh
[[ -f "$ZSH/oh-my-zsh.sh" ]] && source "$ZSH/oh-my-zsh.sh"

# Set PATH at the very beginning
path=(
    # System paths
    "/usr/local/bin"
    "/usr/bin"
    "/bin"
    "/usr/sbin"
    "/sbin"
    "/opt/homebrew/bin"
    # Additional paths
    "/opt/homebrew/opt/curl/bin"
    "/opt/homebrew/opt/unzip/bin"
    "/opt/homebrew/opt/openjdk/bin"
    "/opt/homebrew/opt/icu4c@77/bin"
    "/opt/homebrew/opt/icu4c@77/sbin"
    "$HOME/.codeium/windsurf/bin"
    "$HOME/.nvm/versions/node/v23.8.0/bin"
    "$HOME/.local/bin"
    "$HOME/dotfiles-local/zsh-git-prompt/src/.bin"
    "$HOME/.cargo/bin"
    "$HOME/bin"
    "$HOME/code/youversion/openapi/redcli"
    "$HOME/code/youversion/bi-tools"
    "$GOPATH/bin"
    "$HOME/code/youversion/yv/bin"
)
# Note: Removed $path[@] to prevent duplicates. PATH deduplication happens at the end.

# Initialize pyenv if available
if command -v pyenv 1>/dev/null 2>&1; then
    # Ensure no existing pyenv function conflicts
    unset -f pyenv 2>/dev/null || true
    eval "$(pyenv init -)"
    eval "$(pyenv virtualenv-init -)"
fi
# Lazy load NVM
export NVM_DIR="$HOME/.nvm"
nvm() {
  unfunction nvm
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
  nvm "$@"
}
node() {
  unfunction node
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  node "$@"
}
npm() {
  unfunction npm
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  npm "$@"
}
# Set up Go environment (cached)
if [[ -z "$GOROOT" ]] && command -v brew >/dev/null 2>&1; then
  export GOROOT="$(brew --prefix golang 2>/dev/null)/libexec"
fi
export GOPATH="$HOME/go"
# Source powerlevel10k
source /opt/homebrew/share/powerlevel10k/powerlevel10k.zsh-theme
source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh
# Editor setting
export EDITOR="code -w"

# History configuration
HISTSIZE=5000
SAVEHIST=5000
setopt HIST_IGNORE_SPACE
setopt HIST_IGNORE_DUPS
setopt HIST_EXPIRE_DUPS_FIRST

alias undo='git restore --staged . && git restore . && git clean -fd'
alias be='bundle exec'
alias status='git status'
alias commit='git commit'
alias add='git add .'
alias rspec='bundle exec rspec'
alias refresh='source ~/.zshrc'
alias bug='pytest -sxv tests --last-failed --pdb'
alias mouse='tmux set mouse'
alias sniff="sniffer -x tests"
alias gagrc='git add .; git rebase --continue'
alias new='git checkout -b'
alias z='vim  ~/dotfiles/zshrc.local'
alias nyan='cd ~/go-nyancat && ./go-nyancat | lolcat'
alias gl="git log --oneline --decorate --graph -10"
alias gti='git'
alias bu="brew update"
alias _rebase='git pull origin main --rebase'
alias k='kubectl'
alias gemini-cli='gemini'

# Keep your existing functions
# [Rest of your functions remain the same]

# Load evalcache for performance
[[ -f "$HOME/dotfiles/evalcache.zsh" ]] && source "$HOME/dotfiles/evalcache.zsh"

# Lazy load jump and fnm using evalcache
if command -v jump >/dev/null 2>&1; then
  if command -v _evalcache >/dev/null 2>&1; then
    _evalcache jump shell
  else
    jump() {
      unfunction jump j 2>/dev/null
      eval "$(command jump shell)"
      jump "$@"
    }
    # Create j alias that also lazy loads
    j() {
      unfunction jump j 2>/dev/null
      eval "$(command jump shell)"
      j "$@"
    }
  fi
fi

if command -v fnm >/dev/null 2>&1; then
  if command -v _evalcache >/dev/null 2>&1; then
    _evalcache fnm env --use-on-cd
  else
    fnm() {
      unfunction fnm
      eval "$(command fnm env --use-on-cd)"
      fnm "$@"
    }
  fi
fi

# Source Google Cloud SDK
if [ -f "$HOME/google-cloud-sdk/path.zsh.inc" ]; then
    source "$HOME/google-cloud-sdk/path.zsh.inc"
fi

if [ -f "$HOME/google-cloud-sdk/completion.zsh.inc" ]; then
    source "$HOME/google-cloud-sdk/completion.zsh.inc"
fi

export USE_GKE_GCLOUD_AUTH_PLUGIN=True
export LEFTHOOK=0

# Source cargo environment if it exists
[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# Source git utilities from separate file
[[ -f "$HOME/dotfiles/git-large-file-fix" ]] && source "$HOME/dotfiles/git-large-file-fix"

# Load fzf key bindings and completion
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Hook direnv into the shell after pyenv is loaded
if command -v _evalcache >/dev/null 2>&1; then
  _evalcache direnv hook zsh
elif command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi

# Initialize yv if available
if [ -f "/Users/joshwren/Code/youversion/yv/bin/yv" ]; then
  if command -v _evalcache >/dev/null 2>&1; then
    _evalcache /Users/joshwren/Code/youversion/yv/bin/yv init -
  else
    eval "$(/Users/joshwren/Code/youversion/yv/bin/yv init -)"
  fi
fi

export DOCKER_HOST="unix://${HOME}/.colima/default/docker.sock"

# Background update check for brew and npm
function check_package_updates() {
  local cache_file="$HOME/.cache/package_updates_check"
  local cache_duration=$((24 * 60 * 60)) # 24 hours in seconds

  # Create cache directory if it doesn't exist
  mkdir -p "$(dirname "$cache_file")"

  # Check if cache file exists and is recent
  if [[ -f "$cache_file" ]]; then
    local last_check=$(stat -f %m "$cache_file" 2>/dev/null || echo 0)
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_check))

    if [[ $time_diff -lt $cache_duration ]]; then
      return 0
    fi
  fi

  # Run checks in background
  {
    local updates=""

    # Check brew updates
    if command -v brew >/dev/null 2>&1; then
      local brew_outdated=$(brew outdated 2>/dev/null | wc -l | tr -d ' ')
      if [[ $brew_outdated -gt 0 ]]; then
        updates="${updates}üì¶ Homebrew: $brew_outdated package(s) can be updated (run 'brew upgrade')\n"
      fi
    fi

    # Check npm global updates
    if command -v npm >/dev/null 2>&1; then
      local npm_outdated=$(npm outdated -g 2>/dev/null | tail -n +2 | wc -l | tr -d ' ')
      if [[ $npm_outdated -gt 0 ]]; then
        updates="${updates}üì¶ npm: $npm_outdated global package(s) can be updated (run 'npm update -g')\n"
      fi
    fi

    # Update cache file
    touch "$cache_file"

    # Show updates if any
    if [[ -n "$updates" ]]; then
      echo "\n${updates}" >> "$cache_file.log"
      # Only show notification if there are updates
      echo -e "$updates"
    fi
  } &!
}

# Run check on shell startup
check_package_updates

function fix_colima_docker() {
  echo "üîç Checking DOCKER_HOST..."
  if [[ -n "$DOCKER_HOST" ]]; then
    echo "‚ö†Ô∏è  DOCKER_HOST is set to: $DOCKER_HOST"
    echo "üßπ Unsetting DOCKER_HOST"
    unset DOCKER_HOST
  fi

  echo "üê≥ Testing Docker connection..."
  if docker ps > /dev/null 2>&1; then
    echo "‚úÖ Docker is working fine."
    return 0
  fi

  echo "‚ùå Docker connection failed. Attempting to fix..."

  echo "üõë Stopping Colima..."
  colima stop

  echo "üóëÔ∏è Deleting Colima (this will wipe container data)..."
  echo "y" | colima delete

  echo "üöÄ Restarting Colima..."
  colima start --arch aarch64 --mount "$HOME" --dns 1.1.1.1

  echo "üîÅ Switching Docker context to 'colima'..."
  docker context use colima

  echo "‚è≥ Waiting for Docker to respond..."
  for i in {1..10}; do
    if docker ps > /dev/null 2>&1; then
      echo "‚úÖ Docker is working again!"
      return 0
    fi
    sleep 2
  done

  echo "‚ùå Docker still not responding after restart."
  return 1
}

# Source work-specific configuration
[[ -f "$HOME/dotfiles/work.zsh" ]] && source "$HOME/dotfiles/work.zsh"

# Deduplicate PATH entries while preserving order (must be at the very end)
# This removes duplicates added by tools like pyenv, google-cloud-sdk, rbenv, etc.
typeset -U path
export PATH
